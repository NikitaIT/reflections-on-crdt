Когда я начал изучать распределенные базы данных и crdt - это было многообещающе по многим причинам:

[ха]
1. Кажется, что это что-то новое.
2. Кажется, что это бесплатно.
3. Кажется, что это решит много проблем в проекте и позволит делать удивительные вещи.

Я начал с чтения статей из википедии [[10](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)] и научных статей [[20](https://hal.inria.fr/hal-00932836/file/CRDTs_SSS-2011.pdf)] с 2011 года, наверное все с них начинают.

[ха-ха]
1. Это казалось очень простым и понятным без PhD по CS.
2. Я обнаружил что уже давно использую это, не зная об этом, я даже хотел заменить vuex (это отвратительный redux), на акторов.
3. Казалось, что можно использовать это не вдаваясь в детали.
4. Казалось, что есть много решений, которые просто работают из коробки.

Уже зная что можно делать композицию из CRDT. И зная что такое теория патчей [[30](https://www.researchgate.net/publication/258521116_A_Categorical_Theory_of_Patches)], Difference synchronization [[40](https://static.googleusercontent.com/media/research.google.com/ru//pubs/archive/35605.pdf)] и operational transformation [[50](https://www.researchgate.net/publication/301282694_Operational_Transformation_In_Co-Operative_Editing)]
Я прочитал про JSON-CRDT [[60](https://www.cl.cam.ac.uk/~arb33/papers/KleppmannBeresford-CRDT-JSON-TPDS2017.pdf)].

Было очевидно, что используя слепки состояния невозможно выразить намерения, а значит операции отката/применения/репликации не могут операться на состояние.

[ха-ха-ха]
1. Казалось, что композиция CRDT и унифицированные CRDT это правильный путь.
2. Казалось, что выражение операций как данных в виде сообщений в очередях, а не эвентов фиксирующих изменения, способны выразить намерения, которые можно будет воспроизводить.

Спустя некоторое время я решил проверить видео-контент на ютубе, записи выступлений на конференциях - хороший способ узнать мир вокруг.
Естественно, посмотрел русскоязычный доклад Виктора Грищенко [[70](https://www.youtube.com/watch?v=1ddm7WCMclA&t=4s)], там я узнал про MVCC и прочитал несколько статей про разные базы данных и подходы к реализации транзакций. 
Встатьях про БД было много отсылок к очень древним исследованиям. Получается что чтобы нормально разобраться в CRDT, нужно разобраться в таких штуках как темпоральная логика, алгебра Алена, параллелизм и огромного числа алгоритмов и структур данных на графах. Да, не этого я ждал в начале. Пришлось даже посмотреть на lock-free хэш таблицы и CAS, потому что они построены на схожих принципах, что и CRDT.

[ха]
1. Оказалось, что CRDT это новый взгляд, на что-то старое.
2. Оказалось, что мало того что нужно выбирать реализацию самих CRDT, но и в зависимости от выбора может быть нужен надежный транспорт без потерь, дублирования, переупорядочивания и ещё куча ограничений.
3. Оказалось, что CRDT это проблема, и если хочется делать удивительные вещи, то придется страдать.

[ха-ха]
1. Лучше сначала получить PhD.
2. Моя реализация была простовата(это был наблюдаемый Set CRDT), и это то от чего я захотел избавиться, либо улучшить, когда узнал про CRDT. Я всё ещё совмещаю её с патчами и OT, и я ещё скажу почему.
3. Оказалось, что это надо хорошо понимать, чтобы поддерживать.
4. Оказалось, что чтобы сделать хороший CRDT нужно делать операции из предметной области, а значит готовые решения не будут работать из коробки.

[ха-ха-ха]
1. Композиция приводит к сильному усложнению, представьте что у вас есть 2 массива рядом, и у них разные методы. Думаю вам не понравится эта абстракция.
2. Вчера я хотел айфон и положил его в корзину с ноутбука. Сегодня хочу самсунг и положил его в корзину с планшета. Жена зашла на ноутбук - в корзине 2 телефона. 
  1. Намерения могут измениться во времени. Операции определяют намерения только в момент совершения. 
  2. Отсутствие операции тоже выражает намерение.
  3. Почти все операции имеют контекст (А когда нет? - При фиксированном настоящем будущее независимо от прошлого.). Можно конечно делать допущения для вещей, ктороые не имеют серьёзных последствий в случае неверной интерпретации намерений при слиянии, например лайки в социальных сетях.

Какие практические выводы я сделал на текущий момент?

Если ошибки в интерпретации намерения операции на сайте стоят денег(ха-ха, я знаю аж две корзины покупок, в которых из-за crdt можно купить больше).
То нельзя делать оптимистичное обновление между репликами. Нужно всегда делать как в git, мастер ветка, по ветке для каждого клиента и возможность, либо необходимость, мержить изменения клиентом.
Условно если у вас есть корзина покупок, то логичнее добавить кнопку вроде "Кажется вы добавляли товары в корзину с другого устройства, добавить?" и "Отклонить".
Естественно, в сложных системах, особенно финансовых, стоит предоставлять интерфейс слияния, лишь предлагая реализацию слияния по умолчанию. Благодаря crdt и дополнительным знаниям из предметной области вы почти всегда сможете точно указать пользователю, где вам недостаточно знаний для автоматического слияния.

Время на репликах при хранении лога сходится, можно лучше упорядочить лог операций.
CRDT позволяет сделать много полезного, но пусть пользователь решает, что 10+4 это +4 или =14, а не разработчик.
Иногда изменять значение crdt нужно на уровне объекта(т.е. делать value object, а не entity), а не свойства, т.к. условно в списке задачь может оказаться, что мы попетили задачу как сделанную, а на другой реплике изменили название, в итоге мы отметили не ту задачу.
